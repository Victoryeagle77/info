<app>
    <div class="txt">
	    <form onsubmit={action_valider}>
			<br>Taper ici l'artiste / le groupe, la musique ou l'album que vous souhaitez chercher. Filtrez ou triez votre recherche en cochant les cases suivantes. Il vous est possible d'activer un filtre et un tri en même temps.
			<p>
				<!-- Champs de texte auto-complété !-->
				<input oninput={()=>action_saisir($('input').value)} 
					placeholder="Recherche" list="completion">
				<!-- Proposition d'auto-complétion !-->
				<datalist id="completion">
					<!-- En ce qui concerne les noms d'auteurs,
					et titres d'albums ou de musique !-->
					<option each={i in data.parametre} 
						value={i.name != undefined ? i.name : i.title}></option>
				</datalist>
			</p>

			<!-- Filtres et tris de la recherche !-->
			<br><h3>Filtres et tris de recherche</h3>
			<div id="liste">
			    <!-- Filtres !-->
			    <h3 id="legende">♬ Filtres ♬</h3>
			    <hr><filtre each = {i in data.recherche}
				    legende = {i.legende} filtrage = {i.filtrage}
					onchange = {action_filtrer}>
				</filtre>
			</div>
			<div id="liste">
				<!-- Tris !-->
				<h3 id="legende">♬ Tris ♬</h3><hr>
				<tri onchange = {action_trier}></tri>
			</div>

			<br><br><button type="submit">Confirmer</button>
		</form>

		<!-- Résultats des recherches !-->
		<br><h2>Résultats des recherches</h2>

		<!-- Slider permettant de faire défiler les pages !-->
		<p>
			<!-- Page suivante !-->
			<button class="slider" onclick={action_slider}
				if={(data.parametre[0] != undefined) && (data.page > 0)}><</button>
			
			<!-- Pages intermédiaires !-->
			<button class="slider focus" onclick={action_slider}
				if={(data.parametre[0] != undefined) && (data.page > 0)}>
				{data.page}</button>
			<button class="slider" if={(data.parametre[0] != undefined)}>
				{data.page + 1}</button>
			<button class="slider focus" onclick={action_slider}
				if={(data.parametre[0] != undefined) && (data.page > 0) && 
				(data.page < (data.parametre.length)/10 - 1)}>{data.page + 2}</button>
			<!-- Page précédente !-->
			<button class="slider" onclick={action_slider}
				if={(data.parametre[0] != undefined) &&
				(data.page < (data.parametre.length)/10 - 1)}>></button>
		</p>

		<!-- Nombre d'éléments à afficher pour une page, 
		ains que pour la page suivante !-->
		<resultat each = {i in (data.parametre.slice(
				data.page * 10, (data.page + 1) * 10))}
			type = {i.type} titre = {i.title}
			createur = {i.name} pays = {i.country}
			date = {i.date} score = {i.score} 
			tags = {i.tags} status = {i.status}>
		</resultat>
		<p><br></p>
	</div>

	<script>
		export default{
			/* Structure de données nécessaire aux fonctions évènementielles */
			data : {
				parametre : [],
				evenement : null,
				page : 0, limite : 0,
				/* Indications affichées au-dessus des checkbox correspondantes */
				recherche : [
					{"legende" : "Choix par musique", "filtrage" : "musique"},
					{"legende" : "Choix par auteur", "filtrage" : "auteur"},
					{"legende" : "Choix par album", "filtrage" : "album"}
				],
				/* Verifier les cases cochées */
				filtrage : [ {"filtrage" : "auteur"},
					{"filtrage" : "musique"}, {"filtrage" : "album"} ]
			},

			/**
			* @constructor action_valider
			* Permet de déséléctionner les boutons
			* Lors de la confirmation ou d'un changement d'élément.
			*/
			action_verifier(){
				let selection = document.getElementsByTagName('input');
				for(let i = 0; i < selection.length; i++){
					if(selection[i].type == 'radio')
						selection[i].checked = false;
				}
			},

			/**
			* @constructor action_valider
			* @param event
			* Permet de valider avec le bouton "Confirmer",
			* si le choix ne sait pas directement affiché à l'écran.
			*/
			action_valider(event){
				/* Décocher les options */
				this.action_verifier();
				event.preventDefault();
				/* Retourner à la première page */
				this.data.page = 0;
				/* Confirmer la recherche */
				this.action_saisir(event.target[0].value);
			},

			/**
			* @constructor action_saisir
			* @param event
			* Résultats à afficher lors de la saisie.
			*/
			action_saisir(event){
				/* Décocher les options */
				this.action_verifier();
				/* Retourner à la première page */
				this.data.page = 0;
				this.data.parametre = [];
				this.data.evenement = event;
				/* Limite de temps pour ne pas envoyer trop rapidement une requête */
				if(Date.now() - this.data.limite >= 500){
					/* Récuper les auteurs d'album ou musique */
					this.api.getCreator(event).then((object)=>{
						for(let i in object)
							this.data.parametre.push(object[i]);
						this.update();
					});

					/* Récuper les musiques */
					this.api.getSong(event).then((object)=>{
						for(let i in object)
							this.data.parametre.push(object[i]);
						this.update();
					});

					/* Récuper les album */
					this.api.getAlbum(event).then((object)=>{
						for(let i in object)
							this.data.parametre.push(object[i]);
						this.update();
					});
					/* Réinitialiser le temps */
					this.data.limite = Date.now();
				}else{ return -1; }
			},

			/**
			* @constructor action_filtrer
			* @param event
			* Permet de rechercher les éléments,
			* en les filtrants par type de recherche.
			*/
			action_filtrer(){
				this.data.parametre = [];
				/* Retourner à la première page */
				this.data.page = 0;
				/* Reinitialiser les boutons radios */
				for(let i=0; i<2; i++)
					document.getElementById(i).checked = false;

				if(document.getElementById('auteur').checked){
					/* Récuper les auteurs d'album ou musique */
					this.api.getCreator(this.data.evenement).then((object)=>{
						for(let i in object)
							this.data.parametre.push(object[i]);
						this.update();
					});
				 }else if(document.getElementById('musique').checked){
					/* Récuper les musiques */
					this.api.getSong(this.data.evenement).then((object)=>{
						for(let i in object)
							this.data.parametre.push(object[i]);
						this.update();
					});
				}else if(document.getElementById('album').checked){		
					/* Récuper les album */
					this.api.getAlbum(this.data.evenement).then((object)=>{
						for(let i in object)
							this.data.parametre.push(object[i]);
						this.update();
					});
				}
			},

			/**
			* @constructor trier
			* @param back : élément précédent
			* @param next : élément suivant
			* Fonction de trie par ordre alphabétique
			* @return l'odre de rangement alphabétique
			*/
			trier(back, next){
				let suivant, precedent;
				/* Comparaison des titres et noms */
				(back.title == undefined) ? 
					suivant = back.name : suivant = back.title;
				(next.title == undefined) ? 
					precedent = next.name : precedent = next.title;
				/* Ignorer les majuscules */
				precedent = precedent.toLowerCase();
				suivant = suivant.toLowerCase();
				/* Ordonner les titres et noms */
				if(suivant < precedent){ return -1 }
				else if(suivant > precedent){ return 1; }
				else{ return 0; }
			},

			/**
			* @constructor action_trier
			* @param event 
			* Séléction du trie par ordre alphabétique ou inverse 
			*/
			action_trier(event){
				/* Ordre alphabétique */
				if(event.target.value == "abc")
				 	this.data.parametre.sort(this.trier);
				/* Ordre inverse de celui alphabétique */
				else if(event.target.value == "cba")
					this.data.parametre.reverse(
						this.data.parametre.sort(this.trier));
				this.update();
			},

			/**
			* @function action_slider
			* @param event
			* Permet de changer de pagination
			*/
			action_slider(event){
				/* Page précédente */
				if((event.target.textContent == "<"))
					this.data.page--;
				/* Page suivante */
				else if(event.target.textContent == ">")
					this.data.page++;
				this.update();
			},
		}
	</script>
</app>